SnapEngine Development Guidelines

This guide outlines the structure, development, documentation, and testing practices for SnapEngine, a C++20 game engine developed in Visual Studio. It also covers dependency management using CPM.cmake and API documentation practices.

1. Project Overview
- Project Name: SnapEngine
- Language Standard: C++20
- IDE/Compiler: Visual Studio (MSVC)
- Dependency Manager: CPM.cmake
- Goal: A modular, testable, and well-documented game engine.

2. Repository Structure
SnapEngine/
├─ cmake/
│   └─ cpm.cmake           # Dependency manager
├─ src/
│   ├─ ClassName.h
│   ├─ ClassName.cpp
│   ├─ (One header and source file per class)
├─ main.cpp                # Entry point
├─ CMakeLists.txt
├─ SnapEngine.sln          # Visual Studio solution
└─ Development_Guidelines.txt

- Follow a "one .h and .cpp per class" convention.
- Use main.cpp as the entry point and test harness.

3. Build System & Dependencies
3.1 CPM.cmake Integration
Include cpm.cmake in your project:

include(cmake/cpm.cmake)
CPMAddPackage(NAME SomeLibrary GITHUB_REPOSITORY <user>/<repo> VERSION <version>)
add_executable(SnapEngine main.cpp)
target_link_libraries(SnapEngine PRIVATE SomeLibrary)

3.2 Dependency Documentation
- Name: Assimp
  Repo: https://github.com/assimp/assimp
  Version: 5.2.5
  Purpose: Loads 3D models.

- Name: nlohmann JSON
  Repo: https://github.com/nlohmann/json
  Version: 3.11.3
  Purpose: Handles JSON files.

4. Source Code Conventions
- Classes & Methods: PascalCase (e.g., WindowManager, Initialize()).
- Private Members: m_ prefix (e.g., m_windowWidth).
- Documentation: Use Doxygen-style comments for public APIs.

Example:
/// \class EngineCore
/// \brief Manages the engine's main loop.
class EngineCore {
public:
    /// Initializes the engine.
    static bool Initialize(int width, int height);

    /// Runs the main loop.
    static void Run();

    /// Shuts down the engine.
    static void Shutdown();
};

5. Testing
- Each class includes a static test() function for unit testing using <cassert>.
- Example:
void EngineCore::test() {
    assert(Initialize(800, 600));
    std::cout << "Tests passed!\n";
}

6. Main Entry Point
The main() function supports:
- Command-Line Arguments: --test runs tests.
- Game Execution: Initializes and runs the engine.
Example:
if (runTests) {
    EngineCore::test();
} else {
    EngineCore::Initialize(1280, 720);
    EngineCore::Run();
    EngineCore::Shutdown();
}

7. API Documentation

Window Class
Purpose: Manages a Win32 window.
Public API:
- Window(const std::string& title, int width, int height)
  Sets the window's title and dimensions.
- bool Create()
  Creates the window.
- bool ProcessMessages()
  Handles events, returns false on close.
- HWND GetHandle() (Optional)
  Returns the native window handle.
- static void test()
  Verifies basic functionality.

Example:
Window window("My Game", 800, 600);
if (!window.Create()) return -1;
while (window.ProcessMessages()) {}

ManagerBase Class
Purpose: Abstract base class for managing JSON objects.
Public API:
- void addJsonObject(const nlohmann::json& obj)
  Adds a JSON object.
- const std::vector<nlohmann::json>& getJsonObjects() const
  Returns stored JSON objects.
- virtual void createObjects() = 0
  Derived classes implement this method.

Example Usage:
ManagerBase* manager = new ExampleManager();
manager->addJsonObject({{"name", "example"}});
manager->createObjects();

WindowManager Class
Purpose: Manages multiple windows using JSON data.
Public API:
- void createObjects() override
  Creates Window instances based on JSON objects.

Example JSON:
[
  {"title": "Main Window", "width": 1280, "height": 720},
  {"title": "Secondary Window", "width": 640, "height": 480}
]

DataManager Class
Purpose: Manages multiple managers and loads data from JSON files.
Public API:
- DataManager(const std::string& filename)
  Loads a JSON file.
- bool LoadData()
  Parses and distributes JSON data to managers.
- void CreateManagedObjects()
  Calls createObjects() for all managers.

Example JSON:
[
  {"class": "window", "title": "Game Window", "width": 800, "height": 600}
]

Usage:
DataManager dataManager("config.json");
dataManager.LoadData();
dataManager.CreateManagedObjects();

Model Class
Purpose: Handles 3D models using Assimp.
Public API:
- bool LoadFromFile(const std::string& filePath)
  Loads a 3D model.
- void Draw()
  Renders the model.
- static void test()
  Verifies loading functionality.

8. Collaboration
- Version Control: Use Git with a feature-branch workflow.
- CI/CD: Automate builds and tests on commits and pull requests.

Happy Coding!
SnapEngine Team


SnapEngine Development Guidelines
These guidelines describe how to structure, build, document, and test SnapEngine, a C++20 game engine developed in Visual Studio. This document also outlines how dependencies will be managed using CPM.cmake, as well as how to maintain API and dependency documentation.

1. Project Overview
Project Name: SnapEngine
Language Standard: C++20
IDE/Compiler: Visual Studio (MSVC)
Dependency Manager: CPM.cmake
SnapEngine aims to be a modular, testable, and well-documented framework for building games.

2. Repository Structure
Below is a recommended folder layout. Notice that all .h and .cpp files live directly under src/, maintaining the “one header, one source file” pattern for each class.

SnapEngine/
│
├─ cmake/
│   └─ cpm.cmake                 # Place or fetch CPM.cmake here
│
├─ dependencies/
│   └─ (Optional) local vendor libraries if needed
│
├─ docs/
│   ├─ API_Documentation.md      # Central document referencing all class APIs
│   ├─ Dependencies.md           # Reference for all pulled-in dependencies
│   └─ SnapEngine_Development_Guidelines.md   # (This file)
│
├─ src/
│   ├─ EngineCore.h
│   ├─ EngineCore.cpp
│   ├─ GameLogic.h
│   ├─ GameLogic.cpp
│   ├─ (other classes, one .h + one .cpp for each)
│
├─ tests/
│   └─ (Optional) Additional test resources if needed
│
├─ main.cpp
│
├─ CMakeLists.txt
├─ SnapEngine.sln                # Visual Studio solution file
└─ SnapEngine.vcxproj            # Visual Studio project file (if generated)
Note:

You may further customize the naming or additional subfolders if needed, but each class should still follow the one .h and one .cpp practice.
The main.cpp file acts as the entry point (and test harness).
3. Build System & Dependencies
3.1 CPM.cmake Integration
We use CPM.cmake to fetch and manage external dependencies. Below is a brief outline on how to set up CPM in your top-level CMakeLists.txt:

Include CPM.cmake in your project:

# CMakeLists.txt (top-level)
cmake_minimum_required(VERSION 3.16 FATAL_ERROR)
project(SnapEngine VERSION 0.1.0)

include(cmake/cpm.cmake)  # Ensure 'cpm.cmake' is accessible here

CPMAddPackage(
    NAME SomeLibrary
    GITHUB_REPOSITORY <user>/<repo>
    VERSION <version>
)

# ...
Then, link dependencies to your targets:

add_executable(SnapEngine main.cpp)
target_link_libraries(SnapEngine PRIVATE SomeLibrary)
Update docs/Dependencies.md:
For each external dependency:

Document the repository or package name
Note the version or Git commit used
Briefly explain its purpose
Keep this document up-to-date so that any contributor knows what is currently in use and why.

3.2 Updating Dependencies
Whenever you add or modify dependencies:

Update the relevant CPMAddPackage entries in CMakeLists.txt.
Document the changes in docs/Dependencies.md (e.g., new version, usage notes).
Test the entire engine to ensure nothing breaks.
4. Source Code Conventions
4.1 Class Files
Each class lives in two files under src/:

.h (header): Class definition and public API documentation (using Doxygen-style comments).
.cpp (source): Implementation details + a static test() function for unit testing.
For example:

src/
├─ EngineCore.h
├─ EngineCore.cpp
├─ GameLogic.h
├─ GameLogic.cpp
...
4.2 Naming Conventions
Classes: PascalCase (e.g., EngineCore, GameLogic).
Public Methods: PascalCase (e.g., Initialize(), Update(), Render()).
Private/Protected Methods: camelCase (e.g., loadAssets()).
Member Variables: m_ prefix (e.g., m_windowWidth, m_isRunning).
4.3 Documentation Style
Use Doxygen-style comments for all public-facing methods and classes:

/// \class EngineCore
/// \brief The core engine class responsible for managing the main loop.
///
/// Use this class to initialize the engine, run the game loop, and shut it down.

class EngineCore
{
public:
    /// \brief Initializes the engine with specified parameters.
    /// \param width The width of the window in pixels.
    /// \param height The height of the window in pixels.
    /// \return True if initialization succeeded, false otherwise.
    static bool Initialize(int width, int height);

    /// \brief Runs the main loop of the engine.
    ///
    /// This function blocks until the game exits.
    static void Run();

    /// \brief Shuts down the engine, releasing all resources.
    static void Shutdown();

    /// \brief Runs the unit tests for the EngineCore class.
    ///
    /// Verifies initialization, run, and shutdown behaviors.
    static void test();
    
private:
    static bool m_isInitialized;
};
Key Points:

Brief Summary: A short description of what the function/class does.
Parameters: Describe each parameter.
Return Value: Describe what is returned.
Additional: Mention exceptions thrown, pre/post-conditions, usage notes, etc., if applicable.
4.4 Maintaining API Documentation
Keep a single reference document, docs/API_Documentation.md, outlining:
Each class name
Public functions and a brief summary
Cross-links to the relevant header files for deeper detail (if needed)
Any addition or change to public APIs must be reflected in docs/API_Documentation.md.
5. Testing & Test Functions
Static test() Method
Every class has a static void test() method for basic unit testing.
Use <cassert> or a small testing framework, but keep it self-contained if possible.
Test Conventions
Verify both normal and edge cases.
Print statements indicating test progress and results.
Example in EngineCore.cpp:

void EngineCore::test()
{
    std::cout << "[EngineCore] Running tests...\n";
    
    bool initResult = Initialize(800, 600);
    assert(initResult && "EngineCore initialization failed!");

    // Additional tests...

    Shutdown();
    std::cout << "[EngineCore] Tests passed!\n";
}
If the project grows, consider a small custom test framework or macros if you find yourself repeating patterns.

6. Main Entry Point
A single main() function (in main.cpp) should handle:

Command-Line Arguments
--test or -t triggers test mode.
Running Tests
Call each class’s test() method.
Print pass/fail messages to console.
Running the Game
Initialize the engine (and other subsystems).
Enter the main loop.
On exit, shut down cleanly.
Example main.cpp:

#include <iostream>
#include <string>
#include "EngineCore.h"
#include "GameLogic.h"

int main(int argc, char* argv[])
{
    bool runTests = false;

    for (int i = 1; i < argc; ++i)
    {
        std::string arg = argv[i];
        if (arg == "--test" || arg == "-t")
        {
            runTests = true;
        }
    }

    if (runTests)
    {
        std::cout << "Running SnapEngine tests...\n";
        EngineCore::test();
        GameLogic::test();
        // Add more tests if needed
        std::cout << "Tests completed.\n";
    }
    else
    {
        if (!EngineCore::Initialize(1280, 720))
        {
            std::cerr << "Failed to initialize EngineCore.\n";
            return -1;
        }

        if (!GameLogic::Initialize())
        {
            std::cerr << "Failed to initialize GameLogic.\n";
            return -1;
        }

        EngineCore::Run();

        GameLogic::Shutdown();
        EngineCore::Shutdown();
    }

    return 0;
}
7. Collaboration & Continuous Integration
Version Control: Use Git (or similar). Commit often, with clear messages.
Branching: Adopt a feature-branch workflow (e.g., feature/<name>) and merge via pull requests into main or dev.
CI/CD (optional but recommended):
Automate builds and tests in GitHub Actions, GitLab CI, Azure DevOps, etc.
On each commit or pull request:
Configure & build SnapEngine via CMake.
Run all tests (--test).
Report success/failure to your repository.
8. Documentation Maintenance
API Documentation (docs/API_Documentation.md):

Keep references for all classes and their major methods.
Cross-link to .h files for deeper detail.
Dependencies (docs/Dependencies.md):

List all external libraries with:
Name, version, usage purpose
Special configuration details
Update whenever you add/remove/change a dependency.
SnapEngine Development Guidelines (docs/SnapEngine_Development_Guidelines.md):

This very document.
Update if coding styles, project structure, or other major guidelines change.
9. Conclusion
By following these updated guidelines:

Structure: All .h and .cpp files reside under src/, with each class in its own pair of files.
Documentation: Doxygen-style comments ensure clarity on public APIs, and docs are kept in docs/API_Documentation.md.
Testing: Each class has a test() function to verify correctness.
Build & Dependencies: CPM.cmake keeps external libraries organized, with versions documented in docs/Dependencies.md.
Main Entry Point: A single main.cpp handles command-line arguments, test mode, and normal runtime.
Collaboration: Clear branching, version control, and CI keep the code stable and well-tested.
Adhering to these guidelines ensures a clean, maintainable, and well-documented codebase that both humans and ChatGPT can easily navigate, contribute to, and extend.

API Documentation:
Window Class
Purpose
Creates and manages a single Win32 window (via Windows.h).

Public API

Constructor
Window(const std::string& title, int width, int height)
Sets the window title and size but does not open the window.

bool Create()
Opens the Win32 window. Returns true on success.

bool ProcessMessages()
Processes input and other window events. Returns false if the window has been closed.

HWND GetHandle() const
Returns the native Win32 HWND.

static void test()
Simple test that creates and closes a window.

Example Usage

Window w("Test Window", 800, 600);
if (w.Create()) {
    while (w.ProcessMessages()) {
        // Render or update here...
    }
}
ManagerBase Class
Purpose
An abstract base class that stores and processes nlohmann::json objects. Derived classes define how objects are created from these JSON entries.

Public API

void addJsonObject(const nlohmann::json& jsonObject)
Adds a jsonObject to the internal storage.

const std::vectornlohmann::json& getJsonObjects() const
Returns a constant reference to the collection of stored JSON objects.

virtual void createObjects() = 0
Pure virtual method. Must be overridden by derived classes to process the stored JSON objects and create the desired objects.

Example Usage

ManagerBase* manager = new ExampleManager();
nlohmann::json obj = { {"name", "example"} };
manager->addJsonObject(obj);
manager->createObjects();
ExampleManager Class
Purpose
A concrete implementation of ManagerBase that demonstrates how to create objects from the stored JSON data.

Overrides

void createObjects()
Processes each stored JSON object and creates objects. Throws std::runtime_error if a required field is missing.
Example Usage

ExampleManager manager;
nlohmann::json obj = { {"name", "example"} };
manager.addJsonObject(obj);
manager.createObjects(); // e.g., prints "Creating object with name: example"
Typical Usage Workflow
Instantiate a derived manager (e.g., ExampleManager).
Call addJsonObject to insert JSON objects.
Invoke the overridden createObjects to process and create objects based on the stored JSON.
Notes

Extend ManagerBase by implementing custom creation logic in createObjects.
Ensure JSON objects have the required fields to avoid exceptions.
Complete Example
#include <nlohmann/json.hpp>
#include <iostream>
#include "ManagerBase.h"

int main() {
    ExampleManager manager;
    nlohmann::json obj = { {"name", "example"} };

    manager.addJsonObject(obj);
    manager.createObjects(); // Outputs: "Creating object with name: example"

    return 0;
}

Happy Coding!
SnapEngine Team